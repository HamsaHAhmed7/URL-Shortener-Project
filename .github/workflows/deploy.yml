name: Deploy to AWS (Production)

on:
  push:
    branches: [main]
    paths:
      - 'app/**'
      - 'infra/**'
      - '.github/workflows/deploy.yml'

env:
  AWS_REGION: eu-west-2
  ECR_REPOSITORY: url-shortener
  ECS_CLUSTER: url-cluster-tf
  ECS_SERVICE: url-service-tf
  CONTAINER_NAME: url-shortener-app-tf
  PYTHON_VERSION: '3.11'
  TERRAFORM_VERSION: '1.5.0'

permissions:
  id-token: write
  contents: read
  security-events: write  # For uploading SARIF results
  pull-requests: write    # For commenting

jobs:
  # ==================================
  # Job 1: Security Checks
  # ==================================
  security-checks:
    name: Security Scanning
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      # Python Security Checks
      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      - name: Install dependencies
        working-directory: ./app
        run: |
          pip install --upgrade pip
          pip install -r requirements.txt
          pip install bandit safety flake8 black

      - name: Run Bandit (SAST)
        working-directory: ./app
        run: |
          bandit -r src/ -f json -o bandit-report.json || true
          bandit -r src/ -f txt
        continue-on-error: false

      - name: Check dependencies with Safety
        working-directory: ./app
        run: |
          safety check --json > safety-report.json || true
          safety check
        continue-on-error: false

      - name: Lint Python code
        working-directory: ./app
        run: |
          flake8 src/ --max-line-length=120 --statistics

      - name: Check code formatting
        working-directory: ./app
        run: |
          black --check src/

      # Secrets Scanning
      - name: Scan for secrets with Trivy
        uses: aquasecurity/trivy-action@master
        with:
          scan-type: 'fs'
          scan-ref: '.'
          scanners: 'secret'
          exit-code: '1'
          severity: 'CRITICAL,HIGH'

      - name: Scan for secrets with TruffleHog
        uses: trufflesecurity/trufflehog@main
        with:
          path: ./
          base: ${{ github.event.repository.default_branch }}
          head: HEAD

      # Dockerfile Linting
      - name: Lint Dockerfile with Hadolint
        uses: hadolint/hadolint-action@v3.1.0
        with:
          dockerfile: ./app/Dockerfile
          failure-threshold: error

      # Terraform Security
      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TERRAFORM_VERSION }}

      - name: Terraform Format Check
        working-directory: ./infra
        run: terraform fmt -check -recursive

      - name: Run tfsec
        uses: aquasecurity/tfsec-action@v1.0.3
        with:
          working_directory: ./infra
          soft_fail: false
          format: sarif
          output: tfsec-results.sarif

      - name: Upload tfsec results to GitHub Security
        uses: github/codeql-action/upload-sarif@v3
        if: always()
        with:
          sarif_file: tfsec-results.sarif

      - name: Run Checkov on Terraform
        uses: bridgecrewio/checkov-action@master
        with:
          directory: ./infra
          framework: terraform
          soft_fail: false
          output_format: sarif
          output_file_path: checkov-results.sarif

      - name: Upload Checkov results to GitHub Security
        uses: github/codeql-action/upload-sarif@v3
        if: always()
        with:
          sarif_file: checkov-results.sarif

      - name: Upload security reports
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: security-reports
          path: |
            app/bandit-report.json
            app/safety-report.json
            tfsec-results.sarif
            checkov-results.sarif

  # ==================================
  # Job 2: Testing
  # ==================================
  test:
    name: Run Tests
    runs-on: ubuntu-latest
    needs: security-checks
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      - name: Install dependencies
        working-directory: ./app
        run: |
          pip install --upgrade pip
          pip install -r requirements.txt
          pip install pytest pytest-cov

      - name: Run unit tests
        working-directory: ./app
        run: |
          pytest tests/ -v --cov=src --cov-report=xml --cov-report=term

      - name: Upload coverage reports
        uses: codecov/codecov-action@v4
        if: always()
        with:
          files: ./app/coverage.xml
          fail_ci_if_error: false

  # ==================================
  # Job 3: Build & Scan Docker Image
  # ==================================
  build-and-scan:
    name: Build & Scan Container
    runs-on: ubuntu-latest
    needs: [security-checks, test]
    outputs:
      image: ${{ steps.build-image.outputs.image }}
      digest: ${{ steps.build-image.outputs.digest }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Configure AWS credentials (OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Build Docker image
        id: build-image
        working-directory: ./app
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          IMAGE_TAG: ${{ github.sha }}
        run: |
          docker build \
            --build-arg BUILD_DATE=$(date -u +'%Y-%m-%dT%H:%M:%SZ') \
            --build-arg VCS_REF=${{ github.sha }} \
            --build-arg VERSION=${{ github.sha }} \
            -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG \
            -t $ECR_REGISTRY/$ECR_REPOSITORY:latest \
            .
          
          echo "image=$ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG" >> $GITHUB_OUTPUT
          
          # Get digest
          DIGEST=$(docker inspect --format='{{.Id}}' $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG)
          echo "digest=$DIGEST" >> $GITHUB_OUTPUT

      - name: Scan image with Trivy (Critical & High)
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: ${{ steps.build-image.outputs.image }}
          format: 'sarif'
          output: 'trivy-results.sarif'
          severity: 'CRITICAL,HIGH'
          exit-code: '1'  # Fail on CRITICAL/HIGH

      - name: Upload Trivy results to GitHub Security
        uses: github/codeql-action/upload-sarif@v3
        if: always()
        with:
          sarif_file: trivy-results.sarif

      - name: Scan image with Trivy (Full Report)
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: ${{ steps.build-image.outputs.image }}
          format: 'table'
          severity: 'UNKNOWN,LOW,MEDIUM,HIGH,CRITICAL'

      - name: Scan image with Grype
        uses: anchore/scan-action@v3
        with:
          image: ${{ steps.build-image.outputs.image }}
          fail-build: true
          severity-cutoff: high

      - name: Push image to ECR
        working-directory: ./app
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          IMAGE_TAG: ${{ github.sha }}
        run: |
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:latest

      - name: Generate SBOM (Software Bill of Materials)
        uses: anchore/sbom-action@v0
        with:
          image: ${{ steps.build-image.outputs.image }}
          format: spdx-json
          output-file: sbom.spdx.json

      - name: Upload SBOM
        uses: actions/upload-artifact@v4
        with:
          name: sbom
          path: sbom.spdx.json

  # ==================================
  # Job 4: Terraform Plan
  # ==================================
  terraform-plan:
    name: Terraform Plan
    runs-on: ubuntu-latest
    needs: [security-checks, test]
    defaults:
      run:
        working-directory: ./infra
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TERRAFORM_VERSION }}

      - name: Configure AWS credentials (OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Terraform Init
        run: terraform init

      - name: Terraform Validate
        run: terraform validate

      - name: Terraform Plan
        run: |
          terraform plan \
            -out=tfplan \
            -detailed-exitcode || EXIT_CODE=$?
          
          # Exit code 0 = no changes, 2 = changes present
          if [ $EXIT_CODE -eq 1 ]; then
            echo "Terraform plan failed"
            exit 1
          fi

      - name: Save plan artifact
        uses: actions/upload-artifact@v4
        with:
          name: tfplan
          path: infra/tfplan
          retention-days: 5

  # ==================================
  # Job 5: Approval Gate (Manual)
  # ==================================
  approval:
    name: Manual Approval Required
    runs-on: ubuntu-latest
    needs: [build-and-scan, terraform-plan]
    environment:
      name: production
      url: https://url-shortener.hamsa-ahmed.co.uk
    
    steps:
      - name: Wait for approval
        run: echo "Deployment approved by ${{ github.actor }}"

  # ==================================
  # Job 6: Deploy Infrastructure
  # ==================================
  deploy-infrastructure:
    name: Deploy Infrastructure
    runs-on: ubuntu-latest
    needs: approval
    defaults:
      run:
        working-directory: ./infra
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TERRAFORM_VERSION }}

      - name: Configure AWS credentials (OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Terraform Init
        run: terraform init

      - name: Download plan
        uses: actions/download-artifact@v4
        with:
          name: tfplan
          path: infra/

      - name: Terraform Apply
        run: terraform apply -auto-approve tfplan

      - name: Terraform Output
        id: tf-output
        run: |
          terraform output -json > outputs.json
          echo "alb_dns=$(terraform output -raw alb_dns_name)" >> $GITHUB_OUTPUT

      - name: Upload Terraform outputs
        uses: actions/upload-artifact@v4
        with:
          name: terraform-outputs
          path: infra/outputs.json

  # ==================================
  # Job 7: Deploy Application (Blue/Green)
  # ==================================
  deploy-app:
    name: Deploy to ECS (Blue/Green)
    runs-on: ubuntu-latest
    needs: [deploy-infrastructure, build-and-scan]
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials (OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Get current task definition
        run: |
          aws ecs describe-task-definition \
            --task-definition url-task-definition-tf \
            --query taskDefinition > task-def.json

      - name: Update task definition with new image
        id: task-def
        env:
          IMAGE: ${{ needs.build-and-scan.outputs.image }}
        run: |
          jq --arg IMAGE "$IMAGE" \
            '.containerDefinitions[0].image = $IMAGE | 
             del(.taskDefinitionArn, .revision, .status, .requiresAttributes, 
                 .compatibilities, .registeredAt, .registeredBy)' \
            task-def.json > new-task-def.json
          
          TASK_DEF_ARN=$(aws ecs register-task-definition \
            --cli-input-json file://new-task-def.json \
            --query 'taskDefinition.taskDefinitionArn' \
            --output text)
          
          echo "task-def-arn=$TASK_DEF_ARN" >> $GITHUB_OUTPUT

      - name: Create AppSpec for CodeDeploy
        run: |
          cat > appspec.json << EOF
          {
            "version": 0.0,
            "Resources": [{
              "TargetService": {
                "Type": "AWS::ECS::Service",
                "Properties": {
                  "TaskDefinition": "${{ steps.task-def.outputs.task-def-arn }}",
                  "LoadBalancerInfo": {
                    "ContainerName": "${{ env.CONTAINER_NAME }}",
                    "ContainerPort": 8080
                  }
                }
              }
            }],
            "Hooks": [{
              "BeforeInstall": "LambdaFunctionToValidateBeforeInstall"
            }]
          }
          EOF

      - name: Create CodeDeploy deployment
        id: deploy
        run: |
          DEPLOYMENT_ID=$(aws deploy create-deployment \
            --application-name url-codedeploy-app-tf \
            --deployment-group-name url-codedeploy-dg \
            --revision revisionType=AppSpecContent,appSpecContent={content="$(cat appspec.json | jq -c .)"} \
            --deployment-config-name CodeDeployDefault.ECSAllAtOnce \
            --description "GitHub Actions deployment - SHA ${{ github.sha }} by ${{ github.actor }}" \
            --query 'deploymentId' \
            --output text)
          
          echo "deployment-id=$DEPLOYMENT_ID" >> $GITHUB_OUTPUT
          echo "Deployment ID: $DEPLOYMENT_ID"

      - name: Wait for deployment to complete
        run: |
          echo "Waiting for deployment ${{ steps.deploy.outputs.deployment-id }} to complete..."
          
          aws deploy wait deployment-successful \
            --deployment-id ${{ steps.deploy.outputs.deployment-id }}

      - name: Get deployment status
        run: |
          aws deploy get-deployment \
            --deployment-id ${{ steps.deploy.outputs.deployment-id }} \
            --query 'deploymentInfo.status' \
            --output text

  # ==================================
  # Job 8: Post-Deployment Tests
  # ==================================
  post-deploy-tests:
    name: Post-Deployment Verification
    runs-on: ubuntu-latest
    needs: deploy-app
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Wait for service to stabilize
        run: sleep 60

      - name: Health check
        run: |
          RESPONSE=$(curl -s -o /dev/null -w "%{http_code}" https://url-shortener.hamsa-ahmed.co.uk/healthz)
          if [ "$RESPONSE" != "200" ]; then
            echo "Health check failed with status $RESPONSE"
            exit 1
          fi
          echo "✅ Health check passed"

      - name: Smoke tests
        run: |
          # Test URL shortening
          SHORT_CODE=$(curl -s -X POST https://url-shortener.hamsa-ahmed.co.uk/shorten \
            -H "Content-Type: application/json" \
            -d '{"url":"https://github.com"}' | jq -r '.short')
          
          if [ -z "$SHORT_CODE" ]; then
            echo "Failed to create short URL"
            exit 1
          fi
          
          # Test redirect
          REDIRECT=$(curl -s -o /dev/null -w "%{http_code}" -L https://url-shortener.hamsa-ahmed.co.uk/$SHORT_CODE)
          if [ "$REDIRECT" != "200" ]; then
            echo "Redirect failed"
            exit 1
          fi
          
          echo "✅ Smoke tests passed"

  # ==================================
  # Job 9: Notify
  # ==================================
  notify:
    name: Deployment Notification
    runs-on: ubuntu-latest
    needs: [deploy-app, post-deploy-tests]
    if: always()
    
    steps:
      - name: Deployment Success
        if: needs.deploy-app.result == 'success' && needs.post-deploy-tests.result == 'success'
        run: |
          echo "::notice::✅ Deployment successful!"
          echo "Image: ${{ needs.build-and-scan.outputs.image }}"
          echo "Commit: ${{ github.sha }}"
          echo "Deployed by: ${{ github.actor }}"

      - name: Deployment Failure
        if: needs.deploy-app.result == 'failure' || needs.post-deploy-tests.result == 'failure'
        run: |
          echo "::error::❌ Deployment failed!"
          exit 1